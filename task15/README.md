# Task 15: Работа со строкой

## Описание задачи

К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? 
```go
var justString string
func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}


func main() {
  someFunc()
}
```
Приведите корректный пример реализации.

## Описание проблем

### 1. Утечка памяти

Переменная `justString` ссылается на подстроку строки `v`, которая остаётся в памяти целиком, так как срез строки не копирует данные, а лишь указывает на часть исходного массива байт. Это может привести к значительному расходу памяти, особенно если строка `v` очень велика.

- `v` - это строка длиной 1024 байта.

- `v[:100]` - это ссылка на область памяти строки `v`, на последние 100 байт этой строки.

- `justString = v[:100]` - создание нового объекта, который ссылается на область памяти строки `v`.

Оперируя с `justString` мы взаимодействуем с объектом `v` длиной 1024 байта, из которых используем лишь 100 байт.

Таким образом большая часть данного объекта, остающаяся в памяти, нам не нужна и может считаться утечкой памяти.

#### Решение проблемы - Явное копирование в новую строку

При этом исходная строка `v` может быть освобождена сборщиком мусора если на неё больше нет ссылок, так будет освобождена память, которую она занимала.

`string([]byte(v[:100]))` - создание среза байтов из строки, а затем преобразование этого среза обратно в строку.

Для решения проблемы утечки памяти в таком случае можно использовать следующие подходы:

- Использование `string([]byte(...))` для копирования данных

  Это самый простой и непосредственный способ, который мы уже обсуждали. Он включает создание нового массива байт из подстроки и преобразование этого массива обратно в строку:

```go
justString := string([]byte(v[:100]))
```

- Использование `copy` с предварительно выделенным байтовым срезом
  
Можно создать байтовый срез нужной длины и затем скопировать в него данные из подстроки, после чего преобразовать этот срез в строку. Это может быть более эффективно по памяти, если вы точно знаете длину подстроки:

```go
b := make([]byte, 100)
copy(b, v[:100])
justString := string(b)
```

- Использование буфера для строк

Используя `strings.Builder` или `bytes.Buffer`, вы можете создать буфер, добавить в него данные и затем преобразовать содержимое буфера в строку. Это особенно полезно, если вам нужно построить строку из множества различных фрагментов:

```go
var b strings.Builder
b.WriteString(v[:100])
justString := b.String()
```

- Ручное копирование с помощью цикла
  
В некоторых случаях, особенно если требуется дополнительная обработка данных при копировании, можно использовать цикл для копирования символов из исходной строки в новую:

```go
justBytes := make([]rune, 0, 100)
for _, r := range v[:100] {
    justBytes = append(justBytes, r)
}
justString := string(justBytes)
```

### 2. Отсутствие проверки на длину строки

В коде нет проверки, что длина строки `v` достаточна для того, чтобы безопасно взять срез `v[:100]`. Если строка окажется короче, это приведет к ошибке выполнения (панике).

#### Решение проблемы - Проверка длины строки :)

```go
if len(v) < 100 {
        log.Warn("Строка слишком короткая для взятия среза")
        return // Возможно возврат ошибки
    }
```

### 3. Глобальная переменная для хранения результата

Использование глобальной переменной `justString` для хранения результата работы функции `someFunc` ухудшает модульность и тестируемость кода, так как изменяет состояние вне локальной области видимости функции.

### 4. Неэффективное использование памяти при создании строки

Функция `createHugeString` создаёт строку из массива байт, который инициализируется нулями.

Это строка фиксированной длины, большая часть которой не используется.

#### Можно инициализировать сразу нужный размер строки

- Использовать `strings.Builder`
```go
var builder strings.Builder
builder.Grow(100)
```
- Прямо создать массив байт
```go
data := make([]byte, 100)
```

#### Можно инициализировать строку нужными знаками (если они известны)

```go
for i := 0; i < size; i++ {
	builder.WriteByte('a')
}
```

или

```go
for i := range data {
	data[i] = 'a'
}
```

### 5. Magic number

Использование литерала `1 << 10` без объяснения или выделения в константу с именем затрудняет понимание кода и ухудшает его поддержку. Лучше использовать именованную константу, которая ясно описывает назначение этого значения.

Почему это важно?

- Понятность - код легче читать
- Поддержка - вносить изменения можно централизованно
- Масштабируемость - ясность и централизация упрощают модификацию

#### Решение проблемы - создание константы

```go
const InitialSize = 1 << 10  // 1024 байт
...
v := createHugeString(InitialSize)
```

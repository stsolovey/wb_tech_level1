# Task 18: Concurrent counter

## Описание задачи

Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде. По завершению программа должна выводить итоговое значение счетчика.

## Варианты решения

Для реализации структуры-счетчика, который может безопасно инкрементироваться в многопоточной среде, есть несколько подходов в экосистеме Go. Вот несколько решений, каждое из которых учитывает разные аспекты конкурентности и производительности:

1. **Использование `sync/atomic` пакета**:
    - Простейший и наиболее прямой способ управления доступом к счетчику в конкурентной среде — использование атомарных операций. Пакет `sync/atomic` предоставляет функции для выполнения атомарных загрузок, сохранений и инкрементов.
    - Пример структуры: `type AtomicCounter struct { value int64 }` с методами, использующими `atomic.AddInt64(&c.value, 1)` для инкремента.

2. **Использование мьютексов с пакетом `sync`**:
    - Мьютекс обеспечивает взаимное исключение, блокируя доступ к счетчику во время его обновления. Это обеспечивает строгую последовательность операций над счетчиком.
    - Пример структуры: `type MutexCounter struct { mu sync.Mutex; value int }` с методами, блокирующими и разблокирующими мьютекс при изменении счетчика.

3. **Использование каналов**:
    - Каналы в Go могут использоваться для синхронизации доступа к данным между горутинами, передавая инкремент через канал. Этот подход может быть полезен для сценариев, где контроль над порядком операций критичен.
    - Создание канала для запросов на инкремент и декремент, и горутина, управляющая счетчиком, обрабатывает эти запросы последовательно.





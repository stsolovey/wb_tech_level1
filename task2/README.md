# Task 2: Concurrent computation

## Задание
Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2, 4, 6, 8, 10) и выведет их квадраты в stdout.

## Решения

### solution1: Прямая передача параметров в горутины
Этот подход использует горутины для вычисления квадратов чисел, при этом параметры передаются напрямую в функцию `calculateSquare` из цикла запуска горутин.

**Преимущества:**
- Простота реализации и понимания потока данных.
- Непосредственная передача параметров уменьшает риск захвата изменяемых переменных цикла.

**Недостатки:**
- Может быть менее знакомо новым разработчикам, особенно в контексте захвата переменных в цикле.

### solution2: Использование анонимной функции для передачи параметров
В этом подходе каждое значение массива передается в анонимную функцию, которая вызывает `calculateSquare`. Это обеспечивает явное захватывание текущего значения переменной перед запуском горутины.

**Преимущества:**
- Избежание распространенных ошибок, связанных с захватом переменной цикла.
- Ясное указание области действия переменных, что улучшает поддержку и понимание кода.

**Недостатки:**
- Немного большая сложность кода из-за использования анонимных функций.
- Потенциально большее время выполнения из-за создания дополнительных объектов функций.

### solution3: Работа с каналами и структурами для заданий через паттерн "воркер"
Этот подход вводит структуру `Job` для организации данных и использует каналы для передачи заданий воркерам, которые выполняют вычисления в фиксированном количестве горутин. Воркеры обрабатывают данные, поступающие из общего канала `jobs`, и отправляют результаты через отдельный канал `results`, что позволяет централизованно управлять процессом вычислений.

**Преимущества:**
- **Модульность и абстракция:** Введение структуры `Job` позволяет чётко структурировать данные и задачи, облегчая их управление и расширение.
- **Улучшенное распределение нагрузки:** Фиксированное количество воркеров позволяет более равномерно распределить нагрузку, что улучшает общую производительность и эффективность использования ресурсов.
- **Контроль над параллелизмом:** Ограничение числа горутин обеспечивает лучший контроль над параллельной обработкой, минимизируя издержки на создание и управление горутинами, что критично для систем с ограниченными ресурсами.

**Недостатки:**
- **Управление жизненным циклом каналов:** Необходимость внимательного управления открытием и закрытием каналов может добавлять сложности в коде, особенно в больших и сложных системах.
- **Возможные задержки в обработке:** Использование общих каналов для воркеров может привести к задержкам, если обработка одной задачи займёт значительно больше времени, чем другие.

### solution4: Использование `sync.Map` для хранения результатов
Использует `sync.Map` для безопасного конкурентного хранения результатов вычислений, что обеспечивает безопасный доступ из множества горутин.

**Преимущества:**
- Безопасность при конкурентном доступе без необходимости блокировок.
- Гибкость при работе с динамически изменяемым набором ключей.

**Недостатки:**
- Ниже производительность по сравнению с обычными мапами при определённых условиях.
- Сложность в использовании и понимании механизмов `sync.Map`.

### solution5: Конкурентное вычисление с сохранением результатов в слайс
Этот метод включает прямую запись результатов вычислений квадратов чисел в предварительно выделенный индексированный слайс. Каждая горутина получает конкретный индекс в слайсе, куда она должна записать результат, что исключает необходимость синхронизации доступа к результатам, как это требуется при использовании общих ресурсов (например, каналов или sync.Map).

**Преимущества:**
- Прямой доступ к памяти без использования каналов.
- Эффективное использование памяти и быстрый доступ к результатам.
- Нет необходимости в механизмах синхронизации при записи, если каждая горутина работает с уникальным индексом.

**Недостатки:**
- Требуется внимательное управление индексами слайса для избежания гонок данных. Слайс должен быть заранее определён и выделен, что может ограничивать динамичность обработки данных.
- При неправильном управлении индексами могут возникать гонки данных или другие проблемы синхронизации, если, например, две горутины по ошибке пишут в один и тот же индекс.

### solution6: Использование пула горутин с ограниченным размером
Вместо создания новой горутины для каждого элемента, создаётся пул горутин фиксированного размера, который обрабатывает входящие задачи из канала. Это позволяет более эффективно использовать системные ресурсы, особенно на системах с большим количеством ядер.

**Преимущества:**
- Более эффективное использование ресурсов при фиксированном числе горутин.
- Уменьшение оверхеда на создание и уничтожение горутин.

**Недостатки:**
- Необходимость управления размером пула в зависимости от загрузки системы.
- Возможные задержки в обработке при высокой нагрузке на пул.

### solution7: Использование пакета `reflect.Select`
Использует `reflect.Select` для асинхронного чтения результатов из нескольких каналов, что позволяет обрабатывать результаты по мере их готовности без блокировки.

**Преимущества:**
- Повышенная реактивность и эффективность обработки данных из множества источников.
- Гибкость в управлении множеством каналов без необходимости создания сложных структур управления.

**Недостатки:**
- Сложность использования и понимания `reflect.Select`.
- Потенциальное увеличение сложности кода и управления ошибками из-за динамической природы операций.

### solution8: Использование атомарных операций
Применяет атомарные операции для безопасной записи результатов в память, минимизируя необходимость синхронизации через мьютексы или каналы.

**Преимущества:**
- Высокая производительность за счет отсутствия блокировок.
- Гарантия безопасности операций с памятью при конкурентном доступе.

**Недостатки:**
- Ограниченное использование: атомарные операции подходят не для всех типов данных.
- Необходимость тщательного проектирования для предотвращения сложных ошибок в управлении состоянием.

### Общие рекомендации
В выборе подхода к реализации конкурентности важно учитывать следующие аспекты:
- **Сложность задачи и доступные системные ресурсы.** От этого зависит, будет ли целесообразно использовать более сложные механизмы синхронизации или же можно обойтись простыми решениями.
- **Требования к производительности и масштабируемости.** Некоторые подходы, такие как пулы горутин или атомарные операции, лучше подходят для систем с высокими требованиями к производительности.
- **Читаемость и поддерживаемость кода.** Сложные конструкции могут затруднить дальнейшее развитие и поддержку программы, поэтому выбор должен учитывать баланс между эффективностью и удобством поддержки.
